동시성 제어 방식에 대한 분석 및 보고서 작성

"ConcurrentHashMap"

스레드 안전을 보장하기 위해 각 사용자에 대한 lock('userLocks')을 저장하는 데 사용합니다.
동시 액세스 및 수정을 허용하는 사용자 포인트('UserPoint')를 저장하는 데에도 사용합니다.
동시 읽기를 허용해 스레드의 안정성을 유지하면서 고성능 읽기를 보장합니다. > 읽기 작업이 낳은 시스템에서 빈번한 읽기로 인한 병목현상을 줄일 수 있습니다.
"ReentrantLock"

동일한 사용자에 대한 요청이 순차적으로 처리되도록 각 사용자마다 lock이 생성됩니다.
여러 스레드가 동일한 사용자에 대한 요청을 동시에 처리하려고 하는 것을 방지합니다.
모니터링 및 디버깅에 좋음 isLocked():boolean - 현재 스레드가 lock을 보유하고 있는지 확인 ( lock 설정을 빠르게 확인해야 할 경우 ) getQueueLength() - lock을 기다리는 스레드 수의 추정치를 제공 ( 스레드 경합을 평가하고 성능 병목 현상을 진단해야하는 경우 )
"computeIfAbsent"

'userLocks' 맵에 아직 존재하지 않는 경우에만 사용자에 대한 새 lock이 생성되도록 합니다.
"Memory Cleanup"

lock 대기 중인 스레드가 없는 경우 사용되지 않는 lock은 처리 후 제거 > 잠재적인 메모리 누수를 방지 합니다.
synchronized 를 ConcurrentHashMap으로 수정한 이유

클라이언트 요청 기준으로 클라이언트 마다 lock을 생성하기 위함
동시처리 환경에서 처리량을 향상 > 다른 키에 대한 읽기 및 쓰기는 경합없이 동시에 발생할 수 있음.
synchronized : 일부 동기화 불가능, 멀티코어 시스템에서 확장성이 저하됨, lock이 해제될 때까지 다른 스레드가 무기한 차단됨
